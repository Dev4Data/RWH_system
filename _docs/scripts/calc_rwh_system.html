<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>yenikas_weather.scripts.calc_rwh_system API documentation</title>
<meta name="description" content="wrangle the data and calculate the rain water harvesting (RWH) system
author: Matthis (matthis@email.de)
description:
clean, wrangle and enrich â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>yenikas_weather.scripts.calc_rwh_system</code></h1>
</header>
<section id="section-intro">
<p>wrangle the data and calculate the rain water harvesting (RWH) system
author: Matthis (matthis@email.de)
description:
clean, wrangle and enrich the weather data
calculate the RWH systems with the parameters from the settings.ini
and aggregate it for later analyses and visualisation</p>
<p>functions:
load_csv - load the weatherdata from csv file and calculate required and some need additional data
init_rwh_data - initialise empty fields for later filling with rwh data
calc_rwh_collection - calculate the collected amount of water from one roof
calc_rwh_system - calculate the performance of the RWH design according to the specified parameters
group_rwh_data_ym - group the data by year-month and calculate some aggregates
main - method process to order the calls of the methods and set parameters to create a RWH system
return:
three DataFrames
df - dataset with all calculated data for the RWH system
df_total - summary (like df.describe()) to show a description of the DataFrame
df_ym - aggregated dataset on year-month basis</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;wrangle the data and calculate the rain water harvesting (RWH) system
author: Matthis (matthis@email.de)
description:
    clean, wrangle and enrich the weather data
    calculate the RWH systems with the parameters from the settings.ini
    and aggregate it for later analyses and visualisation

functions:
    load_csv - load the weatherdata from csv file and calculate required and some need additional data
    init_rwh_data - initialise empty fields for later filling with rwh data
    calc_rwh_collection - calculate the collected amount of water from one roof
    calc_rwh_system - calculate the performance of the RWH design according to the specified parameters
    group_rwh_data_ym - group the data by year-month and calculate some aggregates
    main - method process to order the calls of the methods and set parameters to create a RWH system
return:
    three DataFrames
    df - dataset with all calculated data for the RWH system
    df_total - summary (like df.describe()) to show a description of the DataFrame
    df_ym - aggregated dataset on year-month basis

&#34;&#34;&#34;
import pandas as pd
import numpy as np
import os
from pathlib import Path

from yenikas_weather.scripts import setup_environment as env


&#34;&#34;&#34;Show parameters&#34;&#34;&#34;
env.set_pd_environments()
# constants
config = env.get_config()


def load_csv(show_data_overview=False):
    &#34;&#34;&#34;method that load, wrangle and enrich data from weather csv
            datetime data is split in different fields and wrangled
            precipitation data is enriched
            and some data is also categorized in ranges
            unnecessary fields are also dropped

        parameters:
            show_data_overview - True =&gt; some prints to show an overview of the data
        return:
            DataFrame with the data
    &#34;&#34;&#34;
    PROJECT_ROOT = env.get_project_root()
    file_path = &#34;{}/{}&#34;.format(PROJECT_ROOT, config[&#39;files&#39;][&#39;weatherFile&#39;])
    df_tmp = pd.read_csv(file_path)

    &#34;&#34;&#34;wrangle and clean data&#34;&#34;&#34;
    df_tmp[&#39;date&#39;] = df_tmp[&#39;date&#39;].astype({&#39;date&#39;: &#39;datetime64[ns]&#39;})
    # df_tmp = df_tmp.set_index([&#39;date&#39;])
    df_tmp = df_tmp.sort_values(&#39;date&#39;)

    # limit the time frame
    df_tmp = df_tmp[df_tmp[&#39;datetimeStr&#39;] &gt;= config[&#39;weather&#39;][&#39;date_from&#39;]]
    df_tmp = df_tmp[df_tmp[&#39;datetimeStr&#39;] &lt; config[&#39;weather&#39;][&#39;date_till&#39;]]

    # add some data
    df_tmp[&#39;year&#39;] = df_tmp[&#39;date&#39;].dt.year
    df_tmp[&#39;month&#39;] = df_tmp[&#39;date&#39;].dt.month
    df_tmp[&#39;day&#39;] = df_tmp[&#39;date&#39;].dt.day
    df_tmp[&#39;week&#39;] = df_tmp[&#39;date&#39;].dt.week
    df_tmp[&#39;yyyy_mm&#39;] = df_tmp[&#39;date&#39;].dt.strftime(&#39;%Y-%m&#39;)
    #    dayOfWeek = {0: &#39;Monday&#39;, 1: &#39;Tuesday&#39;, 2: &#39;Wednesday&#39;, 3: &#39;Thursday&#39;, 4: &#39;Friday&#39;, 5: &#39;Saturday&#39;, 6: &#39;Sunday&#39;}
    #    df_tmp[&#39;weekday&#39;] = df_tmp[&#39;date&#39;].dt.dayofweek.map(dayOfWeek)
    df_tmp[&#39;rain_season&#39;] = &#34;&#34;

    df_tmp[&#39;precip_h&#39;] = df_tmp[&#39;precipcover&#39;] / 100 * 24
    df_tmp[&#39;precip_mm_h&#39;] = df_tmp[&#39;precip&#39;] / df_tmp[&#39;precip_h&#39;]
    df_tmp[&#39;precip_mm_h&#39;] = df_tmp[&#39;precip_mm_h&#39;].fillna(0)
    df_tmp[&#39;precip_7d&#39;] \
        = df_tmp[&#39;precip&#39;].shift(1) \
         + df_tmp[&#39;precip&#39;].shift(2) \
         + df_tmp[&#39;precip&#39;].shift(3) \
         + df_tmp[&#39;precip&#39;].shift(4) \
         + df_tmp[&#39;precip&#39;].shift(5) \
         + df_tmp[&#39;precip&#39;].shift(6) \
         + df_tmp[&#39;precip&#39;].shift(7)
    df_tmp[&#39;dry_day&#39;] = df_tmp[&#39;precip&#39;].apply(lambda x: 1 if x == 0 else 0).fillna(0)
    df_tmp[&#39;wet_day&#39;] = df_tmp[&#39;precip&#39;].apply(lambda x: 1 if x &gt; 0 else 0).fillna(0)
    df_tmp[&#39;precip_grp&#39;] = df_tmp[&#39;precip&#39;]. \
        apply(lambda x: &#39;00&#39; if x == 0.0 \
            else (&#39;00-02&#39; if 0.0 &lt; x &lt;= 2.0
                  else (&#39;03-05&#39; if 0.2 &lt; x &lt;= 5.0
                        else (&#39;06-10&#39; if 5.0 &lt; x &lt;= 10.0
                              else (&#39;11-20&#39; if 10.0 &lt; x &lt;= 20.00
                                    else &#39;21+&#39;
                                    )
                              )
                        )
                  )
              )

    df_tmp[&#39;wdir&#39;] = df_tmp[&#39;wdir&#39;].fillna(0).round(0).astype(int)

    df_tmp[&#39;precip_25&#39;] = df_tmp[&#39;precip&#39;] / 25
    df_tmp[&#39;precip_25&#39;] = df_tmp[&#39;precip_25&#39;].fillna(0).round(0).astype(int) * 25
    df_tmp[&#39;maxt_5&#39;] = df_tmp[&#39;maxt&#39;] / 5
    df_tmp[&#39;maxt_5&#39;] = df_tmp[&#39;maxt_5&#39;].fillna(0).round(0).astype(int) * 5
    df_tmp[&#39;wdir_10&#39;] = df_tmp[&#39;wdir&#39;] / 10
    df_tmp[&#39;wdir_10&#39;] = df_tmp[&#39;wdir_10&#39;].fillna(0).round(0).astype(int) * 10
    df_tmp[&#39;wspd_5&#39;] = df_tmp[&#39;wspd&#39;] / 5
    df_tmp[&#39;wspd_5&#39;] = df_tmp[&#39;wspd_5&#39;].fillna(0).round(0).astype(int) * 5
    df_tmp[&#39;humidity_20&#39;] = df_tmp[&#39;humidity&#39;] / 20
    df_tmp[&#39;humidity_20&#39;] = df_tmp[&#39;humidity_20&#39;].fillna(0).round(0).astype(int) * 20

    df_tmp.drop(&#39;snow&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;snowdepth&#39;, axis=1, inplace=True)
    #    df_tmp.drop(&#39;windchill&#39;, axis=1, inplace = True)
    df_tmp.drop(&#39;info&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;weathertype&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;datetime&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;solarenergy&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;solarradiation&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;address&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;location&#39;, axis=1, inplace=True)

    if show_data_overview:
        print(df_tmp.info())
        print(df_tmp.head())
        print(df_tmp.tail())
        print(df_tmp.describe())
    return df_tmp


def init_rwh_data(rwh_data):
    &#34;&#34;&#34;initialise empty fileds for RWH calculations&#34;&#34;&#34;
    rwh_data[&#39;collected&#39;] = 0.0
    rwh_data[&#39;net_collected_day&#39;] = 0.0
    rwh_data[&#39;person_consume&#39;] = 0.0
    rwh_data[&#39;garden_consume&#39;] = 0.0
    rwh_data[&#39;water_income&#39;] = 0.0
    rwh_data[&#39;stored&#39;] = 0.0
    rwh_data[&#39;overrun&#39;] = 0.0
    rwh_data[&#39;net_overrun&#39;] = 0.0
    rwh_data[&#39;tank_overrun&#39;] = 0.0
    return rwh_data


def calc_rwh_collection\
    ( df_tmp
      , roof_name
      , max_pipe_throughput
      , max_filter_throughput
      , effective_collection_area
      , rain_buffer_volume
      , show_data_overview=False
      ):
    &#34;&#34;&#34;method to calculate the performance of a RWH component
            calculates the collected water and the water that overruns from gutter or filter
            The overrun from the storage is calculated in the calc_rwh_system method.

        parameters:
            df_tmp - DataFrame with the weather data enriched with data from load_csv method
            roof_name - pre-column name for the roof (mainly for differentiation in the dataset)
            max_pipe_throughput - what is the smallest pipe throughput (liter/minute)
                                    provided by your gutter and downspout
            max_filter_throughput - what is the smallest filter throughput (liter/minute)
            effective_collection_area - the effective collection area of your roof
            rain_buffer_volume - size of the rain buffer tank between pipes and filter
            show_data_overview - True =&gt; some prints to show an overview of the data
        return:
            a enriched dataset with the collected water and also show when the system couldnt manage the volume of rain
    &#34;&#34;&#34;
    # check throughputs
    if effective_collection_area &gt; 0:
        df_tmp[roof_name+&#39;collected_h&#39;] = effective_collection_area * df_tmp[&#39;precip_mm_h&#39;].fillna(0)
        df_tmp[roof_name+&#39;collected_min&#39;] = df_tmp[roof_name+&#39;collected_h&#39;].fillna(0)/60
        df_tmp[roof_name+&#39;collected_day&#39;] = effective_collection_area * df_tmp[&#39;precip&#39;].fillna(0)
        df_tmp[roof_name + &#39;net_collected_day&#39;] = df_tmp[roof_name+&#39;collected_day&#39;]

    # check storage capacity
    df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] = df_tmp[roof_name+&#39;collected_day&#39;].fillna(0)
    pipe_rush_yn = df_tmp[&#39;datetimeStr&#39;] = df_tmp[&#39;datetimeStr&#39;]
    if max_pipe_throughput &gt; 0:
        # if the rain is to strong some water cant be collected
        df_tmp[roof_name+&#39;pipe_rush_min&#39;] \
            = df_tmp[roof_name+&#39;collected_min&#39;] - max_pipe_throughput
        df_tmp[roof_name+&#39;pipe_rush_min&#39;] \
            = df_tmp[roof_name+&#39;pipe_rush_min&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;pipe_rush_day&#39;] \
            = df_tmp[roof_name+&#39;pipe_rush_min&#39;] * 60 * df_tmp[&#39;precip_h&#39;].fillna(0)
        df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] \
            = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;]\
                - df_tmp[roof_name+&#39;pipe_rush_min&#39;] * 60 * df_tmp[&#39;precip_h&#39;].fillna(0)
        df_tmp[roof_name + &#39;net_collected_day&#39;] = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;]
        df_tmp[roof_name + &#39;net_overrun&#39;] = df_tmp[roof_name+&#39;pipe_rush_day&#39;]

        df_tmp[roof_name+&#39;pipe_rush_day&#39;] = df_tmp[roof_name+&#39;pipe_rush_day&#39;].round(0).astype(int)
        df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;].round(0).astype(int)

        df_tmp.drop(roof_name + &#39;pipe_rush_min&#39;, axis=1, inplace=True)

        print(roof_name+&#34; # of days the gutter overrun = &#34; + str(len(df_tmp[df_tmp[roof_name+&#39;pipe_rush_day&#39;] &gt; 0])))
        pipe_rush_yn = df_tmp[roof_name+&#39;pipe_rush_day&#39;] &gt; 0

    filter_rush_yn = df_tmp[&#39;datetimeStr&#39;] = df_tmp[&#39;datetimeStr&#39;]
    if max_filter_throughput &gt; 0\
    and rain_buffer_volume &gt; 0:
        df_tmp[roof_name+&#39;storm_tank_fill_h&#39;] \
            = rain_buffer_volume / df_tmp[roof_name+&#39;collected_h&#39;]
        df_tmp[roof_name+&#39;storm_tank_fill_h&#39;] \
            = df_tmp[roof_name+&#39;storm_tank_fill_h&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;collected_plus_h&#39;] \
            = df_tmp[roof_name+&#39;collected_h&#39;] - max_filter_throughput*60
        df_tmp[roof_name+&#39;collected_plus_h&#39;] \
            = df_tmp[roof_name+&#39;collected_plus_h&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;filter_rush_day&#39;] \
            = (df_tmp[&#39;precip_h&#39;] - df_tmp[roof_name+&#39;storm_tank_fill_h&#39;]) * df_tmp[roof_name+&#39;collected_plus_h&#39;]
        df_tmp[roof_name+&#39;filter_rush_day&#39;] \
            = df_tmp[roof_name+&#39;filter_rush_day&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;] \
            = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] - df_tmp[roof_name+&#39;filter_rush_day&#39;]
        df_tmp[roof_name + &#39;net_collected_day&#39;] = df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;]
        df_tmp[roof_name + &#39;net_overrun&#39;] = df_tmp[roof_name+&#39;filter_rush_day&#39;]

        df_tmp[roof_name+&#39;filter_rush_day&#39;] = df_tmp[roof_name+&#39;filter_rush_day&#39;].round(0).astype(int)
        df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;] = df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;].round(0).astype(int)

        df_tmp.drop(roof_name + &#39;collected_plus_h&#39;, axis=1, inplace=True)

        print(roof_name+&#34; # of days the filter overrun = &#34; + str(len(df_tmp[df_tmp[roof_name+&#39;filter_rush_day&#39;] &gt; 0])))
        filter_rush_yn = df_tmp[roof_name+&#39;filter_rush_day&#39;] &gt; 0

    df_tmp[&#39;collected&#39;] = df_tmp[&#39;collected&#39;] + df_tmp[roof_name + &#39;collected_day&#39;]
    df_tmp[&#39;net_collected_day&#39;] = df_tmp[&#39;net_collected_day&#39;] + df_tmp[roof_name + &#39;net_collected_day&#39;]
    df_tmp[&#39;net_overrun&#39;] = df_tmp[&#39;net_overrun&#39;] + df_tmp[roof_name + &#39;net_overrun&#39;]
    df_tmp[&#39;collected&#39;] = df_tmp[&#39;collected&#39;].round(0).astype(int)
    df_tmp[&#39;net_collected_day&#39;] = df_tmp[&#39;net_collected_day&#39;].round(0).astype(int)
    df_tmp[&#39;net_overrun&#39;] = df_tmp[&#39;net_overrun&#39;].round(0).astype(int)

    storm_yn = np.logical_or(pipe_rush_yn, filter_rush_yn)  # filter overrun

    if show_data_overview:
        print(df_tmp.info())
        print(df_tmp.head(60))
        print(df_tmp.tail(60))
        # print(df_tmp.describe())
    return df_tmp, storm_yn


def calc_rwh_system \
    (rwh_data
     , avg_consumer_no
     , consume
     , garden_usage
     , storage_volume
     , tank_reserves
     , show_data_overview=False
     ):
    &#34;&#34;&#34;method to calculate scenario data for rain water harvesting components
            It calculates the fill state of the storage at a particular date
            And how much water overrun because the storages are full

        parameters:
            rwh_data - DataFrame with weather data and RWH component data
            avg_consumer_no =&gt; average number of persons using water (#)
            consume =&gt; liter a persons use in average at one day (l/day)
            garden_usage =&gt; liter are used for gardening when there is less rain/humidity (l/day)
            storage_volume =&gt; size of all storage volumes in liter
            tank_reserves =&gt; how empty can be the tank before you stop watering the garden
            show_data_overview - True =&gt; some prints to show an overview of the data
       return:
            a enriched dataset with the RWH system performance
    &#34;&#34;&#34;
    rwh_data[&#39;person_consume&#39;] = avg_consumer_no * consume
    stored_last = 0.0
    for index, row in rwh_data.iterrows():
        new_storage = 0.0
        # water just when there is less rain and low humidity
        if row[&#39;precip_7d&#39;] &lt; float(config[&#39;rwh&#39;][&#39;garden_rain_min_mm&#39;]) \
                and row[&#39;humidity&#39;] &lt; float(config[&#39;rwh&#39;][&#39;garden_min_humidity&#39;]) \
                and stored_last &gt; tank_reserves:
            row[&#39;garden_consume&#39;] = garden_usage
            rwh_data.at[index, &#39;garden_consume&#39;] = garden_usage
        row[&#39;water_income&#39;] = row[&#39;net_collected_day&#39;] - row[&#39;person_consume&#39;] - row[&#39;garden_consume&#39;]
        rwh_data.at[index, &#39;water_income&#39;] = row[&#39;water_income&#39;]
        # calc storage fillstate and overrun
        new_storage = stored_last + row[&#39;water_income&#39;]
        if 0 &lt; new_storage &lt;= storage_volume:
            rwh_data.at[index, &#39;stored&#39;] = new_storage
            stored_last = new_storage
        elif new_storage &gt; storage_volume:
            rwh_data.at[index, &#39;stored&#39;] = storage_volume
            rwh_data.at[index, &#39;tank_overrun&#39;] = new_storage - storage_volume
            stored_last = storage_volume
        elif new_storage &lt;= 0:
            stored_last = 0
        if 1 &lt;= row[&#39;month&#39;] &lt; int(config[&#39;rwh&#39;][&#39;season_stat_month&#39;]):
            rwh_data.at[index, &#39;rain_season&#39;] = &#34;rs&#34; + str(row[&#39;year&#39;] - 1)
        else:
            rwh_data.at[index, &#39;rain_season&#39;] = &#34;rs&#34; + str(row[&#39;year&#39;])

    # round values
    rwh_data.loc[:, (&#39;person_consume&#39;)] = rwh_data[&#39;person_consume&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;garden_consume&#39;)] = rwh_data[&#39;garden_consume&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;water_income&#39;)] = rwh_data[&#39;water_income&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;stored&#39;)] = rwh_data[&#39;stored&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;tank_overrun&#39;)] = rwh_data[&#39;tank_overrun&#39;].round(0).astype(int)

    rwh_data[&#39;overrun&#39;] = rwh_data[&#39;net_overrun&#39;] + rwh_data[&#39;tank_overrun&#39;]
    tank_overrun_yn = rwh_data[&#39;tank_overrun&#39;] &gt; 0
    print(&#34; # of days the tank overrun = &#34; + str(len(rwh_data[rwh_data[&#39;tank_overrun&#39;] &gt; 0])))

    rwh_data[&#39;store_filled_pct&#39;] = rwh_data[&#39;stored&#39;] / storage_volume
    rwh_data[&#39;store_filled_grp&#39;] = rwh_data[&#39;store_filled_pct&#39;]. \
        apply(lambda x: &#39;00&#39; if x == 0.0 \
            else (&#39;01-10&#39; if 0.0 &lt; x &lt;= 0.1
                    else (&#39;11-33&#39; if 0.1 &lt; x &lt;= 0.33
                          else (&#39;34-66&#39; if 0.33 &lt; x &lt;= 0.66
                                else &#39;67+&#39;
                                )
                          )
                    )
               )
    rwh_data[&#39;tank_empty&#39;] = rwh_data[&#39;store_filled_pct&#39;].apply(lambda x: 1 if x == 0.0 else 0).fillna(0)
    rwh_data[&#39;tank_low&#39;] = rwh_data[&#39;store_filled_pct&#39;].apply(lambda x: 1 if x &lt;= 0.1 else 0).fillna(0)

    if show_data_overview:
        print(rwh_data.info())
        print(rwh_data.head(60))
        print(rwh_data.tail(60))
        # print(rwh_data.describe())
    return rwh_data, tank_overrun_yn


def group_rwh_data_ym(df, group_fields, show_data_overview=False):
    &#34;&#34;&#34;method to group the RWH dataset by defined fields
            It calculates some aggregates and other statistical data

        parameters:
            df - DataFrame with weather data and RWH system data
            group_fields =&gt; fields that should be used for grouping
            show_data_overview - True =&gt; some prints to show an overview of the data
        return:
            a grouped dataset with statistical data
    &#34;&#34;&#34;
    def quantile(x, n):
        return x.quantile(n)

    df_tmp = df.groupby(group_fields, as_index=True, sort=False) \
        .agg(yyyy_mm=(&#34;yyyy_mm&#34;, &#34;min&#34;)
             , days=(&#34;yyyy_mm&#34;, &#34;count&#34;)
             , precip_sum=(&#34;precip&#34;, &#34;sum&#34;)
             , precip_min=(&#34;precip&#34;, &#34;min&#34;)
             , precip_q1=(&#34;precip&#34;, lambda x: np.percentile(x, q=25))
             , precip_avg=(&#34;precip&#34;, np.mean)
             , precip_med=(&#34;precip&#34;, np.median)
             , precip_q3=(&#34;precip&#34;, lambda x: np.percentile(x, q=75))
             , precip_max=(&#34;precip&#34;, &#34;max&#34;)
             , precip_std=(&#34;precip&#34;, np.std)
             , dry_day_sum=(&#34;dry_day&#34;, &#34;sum&#34;)
             , wet_day_sum=(&#34;wet_day&#34;, &#34;sum&#34;)
             , collected_sum=(&#34;collected&#34;, &#34;sum&#34;)
             , net_collected_sum=(&#34;net_collected_day&#34;, &#34;sum&#34;)
             , precip_h_sum=(&#34;precip_h&#34;, &#34;sum&#34;)
             , precip_h_q05=(&#34;precip_h&#34;, lambda x: np.percentile(x, q=5))
             , precip_h_avg=(&#34;precip_h&#34;, np.mean)
             , precip_h_med=(&#34;precip_h&#34;, np.median)
             , precip_h_q95=(&#34;precip_h&#34;, lambda x: np.percentile(x, q=95))
             , precip_mm_h_min=(&#34;precip_mm_h&#34;, &#34;min&#34;)
             , precip_mm_h_avg=(&#34;precip_mm_h&#34;, np.mean)
             , precip_mm_h_max=(&#34;precip_mm_h&#34;, &#34;max&#34;)
             , person_sum=(&#34;person_consume&#34;, &#34;sum&#34;)
             , garden_sum=(&#34;garden_consume&#34;, &#34;sum&#34;)
             , stored_min=(&#34;stored&#34;, &#34;min&#34;)
             , stored_max=(&#34;stored&#34;, &#34;max&#34;)
             , stored_grp_min=(&#34;store_filled_grp&#34;, &#34;min&#34;)
             , stored_grp_max=(&#34;store_filled_grp&#34;, &#34;max&#34;)
             , tank_empty_sum=(&#34;tank_empty&#34;, &#34;sum&#34;)
             , tank_low_sum=(&#34;tank_low&#34;, &#34;sum&#34;)
             , overrun_sum=(&#34;overrun&#34;, &#34;sum&#34;)
             , net_overrun_sum=(&#34;net_overrun&#34;, &#34;sum&#34;)
             , tank_overrun_sum=(&#34;tank_overrun&#34;, &#34;sum&#34;)
             , temp_min=(&#34;temp&#34;, &#34;min&#34;)
             , temp_avg=(&#34;temp&#34;, np.mean)
             , temp_max=(&#34;maxt&#34;, &#34;max&#34;)
             , precipcover_min=(&#34;precipcover&#34;, &#34;min&#34;)
             , precipcover_avg=(&#34;precipcover&#34;, np.mean)
             , precipcover_max=(&#34;precipcover&#34;, &#34;max&#34;)
             , cloudcover_min=(&#34;cloudcover&#34;, &#34;min&#34;)
             , cloudcover_avg=(&#34;cloudcover&#34;, np.mean)
             , cloudcover_max=(&#34;cloudcover&#34;, &#34;max&#34;)
             , humidity_min=(&#34;humidity&#34;, &#34;min&#34;)
             , humidity_avg=(&#34;humidity&#34;, np.mean)
             , humidity_max=(&#34;humidity&#34;, &#34;max&#34;)
             , wspd_min=(&#34;wspd&#34;, &#34;min&#34;)
             , wspd_avg=(&#34;wspd&#34;, np.mean)
             , wspd_max=(&#34;wspd&#34;, &#34;max&#34;)
             , wgust_min=(&#34;wgust&#34;, &#34;min&#34;)
             , wgust_avg=(&#34;wgust&#34;, np.mean)
             , wgust_max=(&#34;wgust&#34;, &#34;max&#34;)
             )
    df_tmp[&#39;precip_avg&#39;] = df_tmp[&#39;precip_avg&#39;].round(2)
    df_tmp[&#39;precip_std&#39;] = df_tmp[&#39;precip_std&#39;].round(2)
    df_tmp[&#39;precip_h_sum&#39;] = df_tmp[&#39;precip_h_sum&#39;].round(0)
    df_tmp[&#39;precip_h_q05&#39;] = df_tmp[&#39;precip_h_q05&#39;].round(1)
    df_tmp[&#39;precip_h_avg&#39;] = df_tmp[&#39;precip_h_avg&#39;].round(1)
    df_tmp[&#39;precip_h_med&#39;] = df_tmp[&#39;precip_h_med&#39;].round(1)
    df_tmp[&#39;precip_h_q95&#39;] = df_tmp[&#39;precip_h_q95&#39;].round(1)
    df_tmp[&#39;precip_mm_h_min&#39;] = df_tmp[&#39;precip_mm_h_min&#39;].round(1)
    df_tmp[&#39;precip_mm_h_avg&#39;] = df_tmp[&#39;precip_mm_h_avg&#39;].round(1)
    df_tmp[&#39;precip_mm_h_max&#39;] = df_tmp[&#39;precip_mm_h_max&#39;].round(1)
    df_tmp[&#39;temp_avg&#39;] = df_tmp[&#39;temp_avg&#39;].round(1)
    df_tmp[&#39;precipcover_avg&#39;] = df_tmp[&#39;precipcover_avg&#39;].round(1)
    df_tmp[&#39;cloudcover&#39;] = df_tmp[&#39;cloudcover_avg&#39;].round(1)
    df_tmp[&#39;humidity_avg&#39;] = df_tmp[&#39;humidity_avg&#39;].round(1)
    df_tmp[&#39;wspd_avg&#39;] = df_tmp[&#39;wspd_avg&#39;].round(1)
    df_tmp[&#39;wgust_avg&#39;] = df_tmp[&#39;wgust_avg&#39;].round(1)

    df_desc = pd.DataFrame({&#39;precip&#39;: df[&#39;precip&#39;].describe()
                               , &#39;precip_h&#39;: df[&#39;precip_h&#39;].describe()
                               , &#39;precip_mm_h&#39;: df[&#39;precip_mm_h&#39;].describe()
                               , &#39;humidity&#39;: df[&#39;humidity&#39;].describe()
                               , &#39;precipcover&#39;: df[&#39;precipcover&#39;].describe()
                               , &#39;cloudcover&#39;: df[&#39;cloudcover&#39;].describe()
                               , &#39;temp&#39;: df[&#39;temp&#39;].describe()
                               , &#39;maxt&#39;: df[&#39;maxt&#39;].describe()
                               , &#39;wspd&#39;: df[&#39;wspd&#39;].describe()
                               , &#39;wgust&#39;: df[&#39;wgust&#39;].describe()
                               , &#39;windchill&#39;: df[&#39;windchill&#39;].describe()})
    df_desc.loc[&#39;05%&#39;] = df.quantile(0.05).round(1)
    df_desc.loc[&#39;95%&#39;] = df.quantile(0.95).round(1)
    df_desc.loc[&#39;97,5%&#39;] = df.quantile(0.975).round(1)
    df_desc.loc[&#39;99%&#39;] = df.quantile(0.99).round(1)
    df_desc.loc[&#39;dtype&#39;] = df_desc.dtypes
    df_desc.loc[&#39;% count&#39;] = df.isnull().mean().round(4)
    df_desc = df_desc.reset_index()
    if show_data_overview:
        print(df_tmp.info())
        print(df_tmp.head(60))
        print(df_tmp.tail(60))
        # print(df_tmp.describe())
    return df_tmp, df_desc


def main():
    &#34;&#34;&#34;main method to order the method calls and fill the parameters from the config file&#34;&#34;&#34;
    df = load_csv(False)
    df = init_rwh_data(df)

    # default RWH parameters
    df, df_storm_gr\
        = calc_rwh_collection\
            (df, config[&#39;rwh&#39;][&#39;r1_name&#39;]
            , eval(config[&#39;rwh&#39;][&#39;r1_max_pipe_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r1_max_filter_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r1_effective_collection_area&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r1_rain_buffer_volume&#39;])
            , False
            )
    df, df_storm_mr\
        = calc_rwh_collection\
            (df, config[&#39;rwh&#39;][&#39;r2_name&#39;]
            , eval(config[&#39;rwh&#39;][&#39;r2_max_pipe_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r2_max_filter_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r2_effective_collection_area&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r2_rain_buffer_volume&#39;])
            , False
            )
    df, df_tank\
        = calc_rwh_system(df  # rwh_data
                         , eval(config[&#39;rwh&#39;][&#39;avg_consumer_no&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;person_consume&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;garden_usage&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;storage_volume&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;tank_reserves&#39;])
                         , True  # show_data_overview
                         )
    print(df[np.logical_or(np.logical_or(df_storm_gr, df_storm_mr), df_tank)].head(30))
    del df_storm_gr
    del df_storm_mr
    del df_tank


    df_ym, df_total = group_rwh_data_ym(df, [&#39;year&#39;, &#39;month&#39;], False)
    print(&#34;Summary of Totals&#34;)
    print(df_total)

    return df, df_total, df_ym


&#34;&#34;&#34;Main run section&#34;&#34;&#34;
main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="yenikas_weather.scripts.calc_rwh_system.calc_rwh_collection"><code class="name flex">
<span>def <span class="ident">calc_rwh_collection</span></span>(<span>df_tmp, roof_name, max_pipe_throughput, max_filter_throughput, effective_collection_area, rain_buffer_volume, show_data_overview=False)</span>
</code></dt>
<dd>
<div class="desc"><p>method to calculate the performance of a RWH component
calculates the collected water and the water that overruns from gutter or filter
The overrun from the storage is calculated in the calc_rwh_system method.</p>
<p>parameters:
df_tmp - DataFrame with the weather data enriched with data from load_csv method
roof_name - pre-column name for the roof (mainly for differentiation in the dataset)
max_pipe_throughput - what is the smallest pipe throughput (liter/minute)
provided by your gutter and downspout
max_filter_throughput - what is the smallest filter throughput (liter/minute)
effective_collection_area - the effective collection area of your roof
rain_buffer_volume - size of the rain buffer tank between pipes and filter
show_data_overview - True =&gt; some prints to show an overview of the data
return:
a enriched dataset with the collected water and also show when the system couldnt manage the volume of rain</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rwh_collection\
    ( df_tmp
      , roof_name
      , max_pipe_throughput
      , max_filter_throughput
      , effective_collection_area
      , rain_buffer_volume
      , show_data_overview=False
      ):
    &#34;&#34;&#34;method to calculate the performance of a RWH component
            calculates the collected water and the water that overruns from gutter or filter
            The overrun from the storage is calculated in the calc_rwh_system method.

        parameters:
            df_tmp - DataFrame with the weather data enriched with data from load_csv method
            roof_name - pre-column name for the roof (mainly for differentiation in the dataset)
            max_pipe_throughput - what is the smallest pipe throughput (liter/minute)
                                    provided by your gutter and downspout
            max_filter_throughput - what is the smallest filter throughput (liter/minute)
            effective_collection_area - the effective collection area of your roof
            rain_buffer_volume - size of the rain buffer tank between pipes and filter
            show_data_overview - True =&gt; some prints to show an overview of the data
        return:
            a enriched dataset with the collected water and also show when the system couldnt manage the volume of rain
    &#34;&#34;&#34;
    # check throughputs
    if effective_collection_area &gt; 0:
        df_tmp[roof_name+&#39;collected_h&#39;] = effective_collection_area * df_tmp[&#39;precip_mm_h&#39;].fillna(0)
        df_tmp[roof_name+&#39;collected_min&#39;] = df_tmp[roof_name+&#39;collected_h&#39;].fillna(0)/60
        df_tmp[roof_name+&#39;collected_day&#39;] = effective_collection_area * df_tmp[&#39;precip&#39;].fillna(0)
        df_tmp[roof_name + &#39;net_collected_day&#39;] = df_tmp[roof_name+&#39;collected_day&#39;]

    # check storage capacity
    df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] = df_tmp[roof_name+&#39;collected_day&#39;].fillna(0)
    pipe_rush_yn = df_tmp[&#39;datetimeStr&#39;] = df_tmp[&#39;datetimeStr&#39;]
    if max_pipe_throughput &gt; 0:
        # if the rain is to strong some water cant be collected
        df_tmp[roof_name+&#39;pipe_rush_min&#39;] \
            = df_tmp[roof_name+&#39;collected_min&#39;] - max_pipe_throughput
        df_tmp[roof_name+&#39;pipe_rush_min&#39;] \
            = df_tmp[roof_name+&#39;pipe_rush_min&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;pipe_rush_day&#39;] \
            = df_tmp[roof_name+&#39;pipe_rush_min&#39;] * 60 * df_tmp[&#39;precip_h&#39;].fillna(0)
        df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] \
            = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;]\
                - df_tmp[roof_name+&#39;pipe_rush_min&#39;] * 60 * df_tmp[&#39;precip_h&#39;].fillna(0)
        df_tmp[roof_name + &#39;net_collected_day&#39;] = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;]
        df_tmp[roof_name + &#39;net_overrun&#39;] = df_tmp[roof_name+&#39;pipe_rush_day&#39;]

        df_tmp[roof_name+&#39;pipe_rush_day&#39;] = df_tmp[roof_name+&#39;pipe_rush_day&#39;].round(0).astype(int)
        df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;].round(0).astype(int)

        df_tmp.drop(roof_name + &#39;pipe_rush_min&#39;, axis=1, inplace=True)

        print(roof_name+&#34; # of days the gutter overrun = &#34; + str(len(df_tmp[df_tmp[roof_name+&#39;pipe_rush_day&#39;] &gt; 0])))
        pipe_rush_yn = df_tmp[roof_name+&#39;pipe_rush_day&#39;] &gt; 0

    filter_rush_yn = df_tmp[&#39;datetimeStr&#39;] = df_tmp[&#39;datetimeStr&#39;]
    if max_filter_throughput &gt; 0\
    and rain_buffer_volume &gt; 0:
        df_tmp[roof_name+&#39;storm_tank_fill_h&#39;] \
            = rain_buffer_volume / df_tmp[roof_name+&#39;collected_h&#39;]
        df_tmp[roof_name+&#39;storm_tank_fill_h&#39;] \
            = df_tmp[roof_name+&#39;storm_tank_fill_h&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;collected_plus_h&#39;] \
            = df_tmp[roof_name+&#39;collected_h&#39;] - max_filter_throughput*60
        df_tmp[roof_name+&#39;collected_plus_h&#39;] \
            = df_tmp[roof_name+&#39;collected_plus_h&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;filter_rush_day&#39;] \
            = (df_tmp[&#39;precip_h&#39;] - df_tmp[roof_name+&#39;storm_tank_fill_h&#39;]) * df_tmp[roof_name+&#39;collected_plus_h&#39;]
        df_tmp[roof_name+&#39;filter_rush_day&#39;] \
            = df_tmp[roof_name+&#39;filter_rush_day&#39;].apply(lambda x: x if x &gt; 0 else 0).fillna(0)
        df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;] \
            = df_tmp[roof_name+&#39;net_gutter_collected_day&#39;] - df_tmp[roof_name+&#39;filter_rush_day&#39;]
        df_tmp[roof_name + &#39;net_collected_day&#39;] = df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;]
        df_tmp[roof_name + &#39;net_overrun&#39;] = df_tmp[roof_name+&#39;filter_rush_day&#39;]

        df_tmp[roof_name+&#39;filter_rush_day&#39;] = df_tmp[roof_name+&#39;filter_rush_day&#39;].round(0).astype(int)
        df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;] = df_tmp[roof_name+&#39;net_rain_buffer_collected_day&#39;].round(0).astype(int)

        df_tmp.drop(roof_name + &#39;collected_plus_h&#39;, axis=1, inplace=True)

        print(roof_name+&#34; # of days the filter overrun = &#34; + str(len(df_tmp[df_tmp[roof_name+&#39;filter_rush_day&#39;] &gt; 0])))
        filter_rush_yn = df_tmp[roof_name+&#39;filter_rush_day&#39;] &gt; 0

    df_tmp[&#39;collected&#39;] = df_tmp[&#39;collected&#39;] + df_tmp[roof_name + &#39;collected_day&#39;]
    df_tmp[&#39;net_collected_day&#39;] = df_tmp[&#39;net_collected_day&#39;] + df_tmp[roof_name + &#39;net_collected_day&#39;]
    df_tmp[&#39;net_overrun&#39;] = df_tmp[&#39;net_overrun&#39;] + df_tmp[roof_name + &#39;net_overrun&#39;]
    df_tmp[&#39;collected&#39;] = df_tmp[&#39;collected&#39;].round(0).astype(int)
    df_tmp[&#39;net_collected_day&#39;] = df_tmp[&#39;net_collected_day&#39;].round(0).astype(int)
    df_tmp[&#39;net_overrun&#39;] = df_tmp[&#39;net_overrun&#39;].round(0).astype(int)

    storm_yn = np.logical_or(pipe_rush_yn, filter_rush_yn)  # filter overrun

    if show_data_overview:
        print(df_tmp.info())
        print(df_tmp.head(60))
        print(df_tmp.tail(60))
        # print(df_tmp.describe())
    return df_tmp, storm_yn</code></pre>
</details>
</dd>
<dt id="yenikas_weather.scripts.calc_rwh_system.calc_rwh_system"><code class="name flex">
<span>def <span class="ident">calc_rwh_system</span></span>(<span>rwh_data, avg_consumer_no, consume, garden_usage, storage_volume, tank_reserves, show_data_overview=False)</span>
</code></dt>
<dd>
<div class="desc"><p>method to calculate scenario data for rain water harvesting components
It calculates the fill state of the storage at a particular date
And how much water overrun because the storages are full</p>
<p>parameters:
rwh_data - DataFrame with weather data and RWH component data
avg_consumer_no =&gt; average number of persons using water (#)
consume =&gt; liter a persons use in average at one day (l/day)
garden_usage =&gt; liter are used for gardening when there is less rain/humidity (l/day)
storage_volume =&gt; size of all storage volumes in liter
tank_reserves =&gt; how empty can be the tank before you stop watering the garden
show_data_overview - True =&gt; some prints to show an overview of the data
return:
a enriched dataset with the RWH system performance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_rwh_system \
    (rwh_data
     , avg_consumer_no
     , consume
     , garden_usage
     , storage_volume
     , tank_reserves
     , show_data_overview=False
     ):
    &#34;&#34;&#34;method to calculate scenario data for rain water harvesting components
            It calculates the fill state of the storage at a particular date
            And how much water overrun because the storages are full

        parameters:
            rwh_data - DataFrame with weather data and RWH component data
            avg_consumer_no =&gt; average number of persons using water (#)
            consume =&gt; liter a persons use in average at one day (l/day)
            garden_usage =&gt; liter are used for gardening when there is less rain/humidity (l/day)
            storage_volume =&gt; size of all storage volumes in liter
            tank_reserves =&gt; how empty can be the tank before you stop watering the garden
            show_data_overview - True =&gt; some prints to show an overview of the data
       return:
            a enriched dataset with the RWH system performance
    &#34;&#34;&#34;
    rwh_data[&#39;person_consume&#39;] = avg_consumer_no * consume
    stored_last = 0.0
    for index, row in rwh_data.iterrows():
        new_storage = 0.0
        # water just when there is less rain and low humidity
        if row[&#39;precip_7d&#39;] &lt; float(config[&#39;rwh&#39;][&#39;garden_rain_min_mm&#39;]) \
                and row[&#39;humidity&#39;] &lt; float(config[&#39;rwh&#39;][&#39;garden_min_humidity&#39;]) \
                and stored_last &gt; tank_reserves:
            row[&#39;garden_consume&#39;] = garden_usage
            rwh_data.at[index, &#39;garden_consume&#39;] = garden_usage
        row[&#39;water_income&#39;] = row[&#39;net_collected_day&#39;] - row[&#39;person_consume&#39;] - row[&#39;garden_consume&#39;]
        rwh_data.at[index, &#39;water_income&#39;] = row[&#39;water_income&#39;]
        # calc storage fillstate and overrun
        new_storage = stored_last + row[&#39;water_income&#39;]
        if 0 &lt; new_storage &lt;= storage_volume:
            rwh_data.at[index, &#39;stored&#39;] = new_storage
            stored_last = new_storage
        elif new_storage &gt; storage_volume:
            rwh_data.at[index, &#39;stored&#39;] = storage_volume
            rwh_data.at[index, &#39;tank_overrun&#39;] = new_storage - storage_volume
            stored_last = storage_volume
        elif new_storage &lt;= 0:
            stored_last = 0
        if 1 &lt;= row[&#39;month&#39;] &lt; int(config[&#39;rwh&#39;][&#39;season_stat_month&#39;]):
            rwh_data.at[index, &#39;rain_season&#39;] = &#34;rs&#34; + str(row[&#39;year&#39;] - 1)
        else:
            rwh_data.at[index, &#39;rain_season&#39;] = &#34;rs&#34; + str(row[&#39;year&#39;])

    # round values
    rwh_data.loc[:, (&#39;person_consume&#39;)] = rwh_data[&#39;person_consume&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;garden_consume&#39;)] = rwh_data[&#39;garden_consume&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;water_income&#39;)] = rwh_data[&#39;water_income&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;stored&#39;)] = rwh_data[&#39;stored&#39;].round(0).astype(int)
    rwh_data.loc[:, (&#39;tank_overrun&#39;)] = rwh_data[&#39;tank_overrun&#39;].round(0).astype(int)

    rwh_data[&#39;overrun&#39;] = rwh_data[&#39;net_overrun&#39;] + rwh_data[&#39;tank_overrun&#39;]
    tank_overrun_yn = rwh_data[&#39;tank_overrun&#39;] &gt; 0
    print(&#34; # of days the tank overrun = &#34; + str(len(rwh_data[rwh_data[&#39;tank_overrun&#39;] &gt; 0])))

    rwh_data[&#39;store_filled_pct&#39;] = rwh_data[&#39;stored&#39;] / storage_volume
    rwh_data[&#39;store_filled_grp&#39;] = rwh_data[&#39;store_filled_pct&#39;]. \
        apply(lambda x: &#39;00&#39; if x == 0.0 \
            else (&#39;01-10&#39; if 0.0 &lt; x &lt;= 0.1
                    else (&#39;11-33&#39; if 0.1 &lt; x &lt;= 0.33
                          else (&#39;34-66&#39; if 0.33 &lt; x &lt;= 0.66
                                else &#39;67+&#39;
                                )
                          )
                    )
               )
    rwh_data[&#39;tank_empty&#39;] = rwh_data[&#39;store_filled_pct&#39;].apply(lambda x: 1 if x == 0.0 else 0).fillna(0)
    rwh_data[&#39;tank_low&#39;] = rwh_data[&#39;store_filled_pct&#39;].apply(lambda x: 1 if x &lt;= 0.1 else 0).fillna(0)

    if show_data_overview:
        print(rwh_data.info())
        print(rwh_data.head(60))
        print(rwh_data.tail(60))
        # print(rwh_data.describe())
    return rwh_data, tank_overrun_yn</code></pre>
</details>
</dd>
<dt id="yenikas_weather.scripts.calc_rwh_system.group_rwh_data_ym"><code class="name flex">
<span>def <span class="ident">group_rwh_data_ym</span></span>(<span>df, group_fields, show_data_overview=False)</span>
</code></dt>
<dd>
<div class="desc"><p>method to group the RWH dataset by defined fields
It calculates some aggregates and other statistical data</p>
<p>parameters:
df - DataFrame with weather data and RWH system data
group_fields =&gt; fields that should be used for grouping
show_data_overview - True =&gt; some prints to show an overview of the data
return:
a grouped dataset with statistical data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_rwh_data_ym(df, group_fields, show_data_overview=False):
    &#34;&#34;&#34;method to group the RWH dataset by defined fields
            It calculates some aggregates and other statistical data

        parameters:
            df - DataFrame with weather data and RWH system data
            group_fields =&gt; fields that should be used for grouping
            show_data_overview - True =&gt; some prints to show an overview of the data
        return:
            a grouped dataset with statistical data
    &#34;&#34;&#34;
    def quantile(x, n):
        return x.quantile(n)

    df_tmp = df.groupby(group_fields, as_index=True, sort=False) \
        .agg(yyyy_mm=(&#34;yyyy_mm&#34;, &#34;min&#34;)
             , days=(&#34;yyyy_mm&#34;, &#34;count&#34;)
             , precip_sum=(&#34;precip&#34;, &#34;sum&#34;)
             , precip_min=(&#34;precip&#34;, &#34;min&#34;)
             , precip_q1=(&#34;precip&#34;, lambda x: np.percentile(x, q=25))
             , precip_avg=(&#34;precip&#34;, np.mean)
             , precip_med=(&#34;precip&#34;, np.median)
             , precip_q3=(&#34;precip&#34;, lambda x: np.percentile(x, q=75))
             , precip_max=(&#34;precip&#34;, &#34;max&#34;)
             , precip_std=(&#34;precip&#34;, np.std)
             , dry_day_sum=(&#34;dry_day&#34;, &#34;sum&#34;)
             , wet_day_sum=(&#34;wet_day&#34;, &#34;sum&#34;)
             , collected_sum=(&#34;collected&#34;, &#34;sum&#34;)
             , net_collected_sum=(&#34;net_collected_day&#34;, &#34;sum&#34;)
             , precip_h_sum=(&#34;precip_h&#34;, &#34;sum&#34;)
             , precip_h_q05=(&#34;precip_h&#34;, lambda x: np.percentile(x, q=5))
             , precip_h_avg=(&#34;precip_h&#34;, np.mean)
             , precip_h_med=(&#34;precip_h&#34;, np.median)
             , precip_h_q95=(&#34;precip_h&#34;, lambda x: np.percentile(x, q=95))
             , precip_mm_h_min=(&#34;precip_mm_h&#34;, &#34;min&#34;)
             , precip_mm_h_avg=(&#34;precip_mm_h&#34;, np.mean)
             , precip_mm_h_max=(&#34;precip_mm_h&#34;, &#34;max&#34;)
             , person_sum=(&#34;person_consume&#34;, &#34;sum&#34;)
             , garden_sum=(&#34;garden_consume&#34;, &#34;sum&#34;)
             , stored_min=(&#34;stored&#34;, &#34;min&#34;)
             , stored_max=(&#34;stored&#34;, &#34;max&#34;)
             , stored_grp_min=(&#34;store_filled_grp&#34;, &#34;min&#34;)
             , stored_grp_max=(&#34;store_filled_grp&#34;, &#34;max&#34;)
             , tank_empty_sum=(&#34;tank_empty&#34;, &#34;sum&#34;)
             , tank_low_sum=(&#34;tank_low&#34;, &#34;sum&#34;)
             , overrun_sum=(&#34;overrun&#34;, &#34;sum&#34;)
             , net_overrun_sum=(&#34;net_overrun&#34;, &#34;sum&#34;)
             , tank_overrun_sum=(&#34;tank_overrun&#34;, &#34;sum&#34;)
             , temp_min=(&#34;temp&#34;, &#34;min&#34;)
             , temp_avg=(&#34;temp&#34;, np.mean)
             , temp_max=(&#34;maxt&#34;, &#34;max&#34;)
             , precipcover_min=(&#34;precipcover&#34;, &#34;min&#34;)
             , precipcover_avg=(&#34;precipcover&#34;, np.mean)
             , precipcover_max=(&#34;precipcover&#34;, &#34;max&#34;)
             , cloudcover_min=(&#34;cloudcover&#34;, &#34;min&#34;)
             , cloudcover_avg=(&#34;cloudcover&#34;, np.mean)
             , cloudcover_max=(&#34;cloudcover&#34;, &#34;max&#34;)
             , humidity_min=(&#34;humidity&#34;, &#34;min&#34;)
             , humidity_avg=(&#34;humidity&#34;, np.mean)
             , humidity_max=(&#34;humidity&#34;, &#34;max&#34;)
             , wspd_min=(&#34;wspd&#34;, &#34;min&#34;)
             , wspd_avg=(&#34;wspd&#34;, np.mean)
             , wspd_max=(&#34;wspd&#34;, &#34;max&#34;)
             , wgust_min=(&#34;wgust&#34;, &#34;min&#34;)
             , wgust_avg=(&#34;wgust&#34;, np.mean)
             , wgust_max=(&#34;wgust&#34;, &#34;max&#34;)
             )
    df_tmp[&#39;precip_avg&#39;] = df_tmp[&#39;precip_avg&#39;].round(2)
    df_tmp[&#39;precip_std&#39;] = df_tmp[&#39;precip_std&#39;].round(2)
    df_tmp[&#39;precip_h_sum&#39;] = df_tmp[&#39;precip_h_sum&#39;].round(0)
    df_tmp[&#39;precip_h_q05&#39;] = df_tmp[&#39;precip_h_q05&#39;].round(1)
    df_tmp[&#39;precip_h_avg&#39;] = df_tmp[&#39;precip_h_avg&#39;].round(1)
    df_tmp[&#39;precip_h_med&#39;] = df_tmp[&#39;precip_h_med&#39;].round(1)
    df_tmp[&#39;precip_h_q95&#39;] = df_tmp[&#39;precip_h_q95&#39;].round(1)
    df_tmp[&#39;precip_mm_h_min&#39;] = df_tmp[&#39;precip_mm_h_min&#39;].round(1)
    df_tmp[&#39;precip_mm_h_avg&#39;] = df_tmp[&#39;precip_mm_h_avg&#39;].round(1)
    df_tmp[&#39;precip_mm_h_max&#39;] = df_tmp[&#39;precip_mm_h_max&#39;].round(1)
    df_tmp[&#39;temp_avg&#39;] = df_tmp[&#39;temp_avg&#39;].round(1)
    df_tmp[&#39;precipcover_avg&#39;] = df_tmp[&#39;precipcover_avg&#39;].round(1)
    df_tmp[&#39;cloudcover&#39;] = df_tmp[&#39;cloudcover_avg&#39;].round(1)
    df_tmp[&#39;humidity_avg&#39;] = df_tmp[&#39;humidity_avg&#39;].round(1)
    df_tmp[&#39;wspd_avg&#39;] = df_tmp[&#39;wspd_avg&#39;].round(1)
    df_tmp[&#39;wgust_avg&#39;] = df_tmp[&#39;wgust_avg&#39;].round(1)

    df_desc = pd.DataFrame({&#39;precip&#39;: df[&#39;precip&#39;].describe()
                               , &#39;precip_h&#39;: df[&#39;precip_h&#39;].describe()
                               , &#39;precip_mm_h&#39;: df[&#39;precip_mm_h&#39;].describe()
                               , &#39;humidity&#39;: df[&#39;humidity&#39;].describe()
                               , &#39;precipcover&#39;: df[&#39;precipcover&#39;].describe()
                               , &#39;cloudcover&#39;: df[&#39;cloudcover&#39;].describe()
                               , &#39;temp&#39;: df[&#39;temp&#39;].describe()
                               , &#39;maxt&#39;: df[&#39;maxt&#39;].describe()
                               , &#39;wspd&#39;: df[&#39;wspd&#39;].describe()
                               , &#39;wgust&#39;: df[&#39;wgust&#39;].describe()
                               , &#39;windchill&#39;: df[&#39;windchill&#39;].describe()})
    df_desc.loc[&#39;05%&#39;] = df.quantile(0.05).round(1)
    df_desc.loc[&#39;95%&#39;] = df.quantile(0.95).round(1)
    df_desc.loc[&#39;97,5%&#39;] = df.quantile(0.975).round(1)
    df_desc.loc[&#39;99%&#39;] = df.quantile(0.99).round(1)
    df_desc.loc[&#39;dtype&#39;] = df_desc.dtypes
    df_desc.loc[&#39;% count&#39;] = df.isnull().mean().round(4)
    df_desc = df_desc.reset_index()
    if show_data_overview:
        print(df_tmp.info())
        print(df_tmp.head(60))
        print(df_tmp.tail(60))
        # print(df_tmp.describe())
    return df_tmp, df_desc</code></pre>
</details>
</dd>
<dt id="yenikas_weather.scripts.calc_rwh_system.init_rwh_data"><code class="name flex">
<span>def <span class="ident">init_rwh_data</span></span>(<span>rwh_data)</span>
</code></dt>
<dd>
<div class="desc"><p>initialise empty fileds for RWH calculations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_rwh_data(rwh_data):
    &#34;&#34;&#34;initialise empty fileds for RWH calculations&#34;&#34;&#34;
    rwh_data[&#39;collected&#39;] = 0.0
    rwh_data[&#39;net_collected_day&#39;] = 0.0
    rwh_data[&#39;person_consume&#39;] = 0.0
    rwh_data[&#39;garden_consume&#39;] = 0.0
    rwh_data[&#39;water_income&#39;] = 0.0
    rwh_data[&#39;stored&#39;] = 0.0
    rwh_data[&#39;overrun&#39;] = 0.0
    rwh_data[&#39;net_overrun&#39;] = 0.0
    rwh_data[&#39;tank_overrun&#39;] = 0.0
    return rwh_data</code></pre>
</details>
</dd>
<dt id="yenikas_weather.scripts.calc_rwh_system.load_csv"><code class="name flex">
<span>def <span class="ident">load_csv</span></span>(<span>show_data_overview=False)</span>
</code></dt>
<dd>
<div class="desc"><p>method that load, wrangle and enrich data from weather csv
datetime data is split in different fields and wrangled
precipitation data is enriched
and some data is also categorized in ranges
unnecessary fields are also dropped</p>
<p>parameters:
show_data_overview - True =&gt; some prints to show an overview of the data
return:
DataFrame with the data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_csv(show_data_overview=False):
    &#34;&#34;&#34;method that load, wrangle and enrich data from weather csv
            datetime data is split in different fields and wrangled
            precipitation data is enriched
            and some data is also categorized in ranges
            unnecessary fields are also dropped

        parameters:
            show_data_overview - True =&gt; some prints to show an overview of the data
        return:
            DataFrame with the data
    &#34;&#34;&#34;
    PROJECT_ROOT = env.get_project_root()
    file_path = &#34;{}/{}&#34;.format(PROJECT_ROOT, config[&#39;files&#39;][&#39;weatherFile&#39;])
    df_tmp = pd.read_csv(file_path)

    &#34;&#34;&#34;wrangle and clean data&#34;&#34;&#34;
    df_tmp[&#39;date&#39;] = df_tmp[&#39;date&#39;].astype({&#39;date&#39;: &#39;datetime64[ns]&#39;})
    # df_tmp = df_tmp.set_index([&#39;date&#39;])
    df_tmp = df_tmp.sort_values(&#39;date&#39;)

    # limit the time frame
    df_tmp = df_tmp[df_tmp[&#39;datetimeStr&#39;] &gt;= config[&#39;weather&#39;][&#39;date_from&#39;]]
    df_tmp = df_tmp[df_tmp[&#39;datetimeStr&#39;] &lt; config[&#39;weather&#39;][&#39;date_till&#39;]]

    # add some data
    df_tmp[&#39;year&#39;] = df_tmp[&#39;date&#39;].dt.year
    df_tmp[&#39;month&#39;] = df_tmp[&#39;date&#39;].dt.month
    df_tmp[&#39;day&#39;] = df_tmp[&#39;date&#39;].dt.day
    df_tmp[&#39;week&#39;] = df_tmp[&#39;date&#39;].dt.week
    df_tmp[&#39;yyyy_mm&#39;] = df_tmp[&#39;date&#39;].dt.strftime(&#39;%Y-%m&#39;)
    #    dayOfWeek = {0: &#39;Monday&#39;, 1: &#39;Tuesday&#39;, 2: &#39;Wednesday&#39;, 3: &#39;Thursday&#39;, 4: &#39;Friday&#39;, 5: &#39;Saturday&#39;, 6: &#39;Sunday&#39;}
    #    df_tmp[&#39;weekday&#39;] = df_tmp[&#39;date&#39;].dt.dayofweek.map(dayOfWeek)
    df_tmp[&#39;rain_season&#39;] = &#34;&#34;

    df_tmp[&#39;precip_h&#39;] = df_tmp[&#39;precipcover&#39;] / 100 * 24
    df_tmp[&#39;precip_mm_h&#39;] = df_tmp[&#39;precip&#39;] / df_tmp[&#39;precip_h&#39;]
    df_tmp[&#39;precip_mm_h&#39;] = df_tmp[&#39;precip_mm_h&#39;].fillna(0)
    df_tmp[&#39;precip_7d&#39;] \
        = df_tmp[&#39;precip&#39;].shift(1) \
         + df_tmp[&#39;precip&#39;].shift(2) \
         + df_tmp[&#39;precip&#39;].shift(3) \
         + df_tmp[&#39;precip&#39;].shift(4) \
         + df_tmp[&#39;precip&#39;].shift(5) \
         + df_tmp[&#39;precip&#39;].shift(6) \
         + df_tmp[&#39;precip&#39;].shift(7)
    df_tmp[&#39;dry_day&#39;] = df_tmp[&#39;precip&#39;].apply(lambda x: 1 if x == 0 else 0).fillna(0)
    df_tmp[&#39;wet_day&#39;] = df_tmp[&#39;precip&#39;].apply(lambda x: 1 if x &gt; 0 else 0).fillna(0)
    df_tmp[&#39;precip_grp&#39;] = df_tmp[&#39;precip&#39;]. \
        apply(lambda x: &#39;00&#39; if x == 0.0 \
            else (&#39;00-02&#39; if 0.0 &lt; x &lt;= 2.0
                  else (&#39;03-05&#39; if 0.2 &lt; x &lt;= 5.0
                        else (&#39;06-10&#39; if 5.0 &lt; x &lt;= 10.0
                              else (&#39;11-20&#39; if 10.0 &lt; x &lt;= 20.00
                                    else &#39;21+&#39;
                                    )
                              )
                        )
                  )
              )

    df_tmp[&#39;wdir&#39;] = df_tmp[&#39;wdir&#39;].fillna(0).round(0).astype(int)

    df_tmp[&#39;precip_25&#39;] = df_tmp[&#39;precip&#39;] / 25
    df_tmp[&#39;precip_25&#39;] = df_tmp[&#39;precip_25&#39;].fillna(0).round(0).astype(int) * 25
    df_tmp[&#39;maxt_5&#39;] = df_tmp[&#39;maxt&#39;] / 5
    df_tmp[&#39;maxt_5&#39;] = df_tmp[&#39;maxt_5&#39;].fillna(0).round(0).astype(int) * 5
    df_tmp[&#39;wdir_10&#39;] = df_tmp[&#39;wdir&#39;] / 10
    df_tmp[&#39;wdir_10&#39;] = df_tmp[&#39;wdir_10&#39;].fillna(0).round(0).astype(int) * 10
    df_tmp[&#39;wspd_5&#39;] = df_tmp[&#39;wspd&#39;] / 5
    df_tmp[&#39;wspd_5&#39;] = df_tmp[&#39;wspd_5&#39;].fillna(0).round(0).astype(int) * 5
    df_tmp[&#39;humidity_20&#39;] = df_tmp[&#39;humidity&#39;] / 20
    df_tmp[&#39;humidity_20&#39;] = df_tmp[&#39;humidity_20&#39;].fillna(0).round(0).astype(int) * 20

    df_tmp.drop(&#39;snow&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;snowdepth&#39;, axis=1, inplace=True)
    #    df_tmp.drop(&#39;windchill&#39;, axis=1, inplace = True)
    df_tmp.drop(&#39;info&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;weathertype&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;datetime&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;solarenergy&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;solarradiation&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;address&#39;, axis=1, inplace=True)
    df_tmp.drop(&#39;location&#39;, axis=1, inplace=True)

    if show_data_overview:
        print(df_tmp.info())
        print(df_tmp.head())
        print(df_tmp.tail())
        print(df_tmp.describe())
    return df_tmp</code></pre>
</details>
</dd>
<dt id="yenikas_weather.scripts.calc_rwh_system.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>main method to order the method calls and fill the parameters from the config file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;main method to order the method calls and fill the parameters from the config file&#34;&#34;&#34;
    df = load_csv(False)
    df = init_rwh_data(df)

    # default RWH parameters
    df, df_storm_gr\
        = calc_rwh_collection\
            (df, config[&#39;rwh&#39;][&#39;r1_name&#39;]
            , eval(config[&#39;rwh&#39;][&#39;r1_max_pipe_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r1_max_filter_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r1_effective_collection_area&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r1_rain_buffer_volume&#39;])
            , False
            )
    df, df_storm_mr\
        = calc_rwh_collection\
            (df, config[&#39;rwh&#39;][&#39;r2_name&#39;]
            , eval(config[&#39;rwh&#39;][&#39;r2_max_pipe_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r2_max_filter_throughput&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r2_effective_collection_area&#39;])
            , eval(config[&#39;rwh&#39;][&#39;r2_rain_buffer_volume&#39;])
            , False
            )
    df, df_tank\
        = calc_rwh_system(df  # rwh_data
                         , eval(config[&#39;rwh&#39;][&#39;avg_consumer_no&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;person_consume&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;garden_usage&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;storage_volume&#39;])
                         , eval(config[&#39;rwh&#39;][&#39;tank_reserves&#39;])
                         , True  # show_data_overview
                         )
    print(df[np.logical_or(np.logical_or(df_storm_gr, df_storm_mr), df_tank)].head(30))
    del df_storm_gr
    del df_storm_mr
    del df_tank


    df_ym, df_total = group_rwh_data_ym(df, [&#39;year&#39;, &#39;month&#39;], False)
    print(&#34;Summary of Totals&#34;)
    print(df_total)

    return df, df_total, df_ym</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="yenikas_weather.scripts" href="index.html">yenikas_weather.scripts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="yenikas_weather.scripts.calc_rwh_system.calc_rwh_collection" href="#yenikas_weather.scripts.calc_rwh_system.calc_rwh_collection">calc_rwh_collection</a></code></li>
<li><code><a title="yenikas_weather.scripts.calc_rwh_system.calc_rwh_system" href="#yenikas_weather.scripts.calc_rwh_system.calc_rwh_system">calc_rwh_system</a></code></li>
<li><code><a title="yenikas_weather.scripts.calc_rwh_system.group_rwh_data_ym" href="#yenikas_weather.scripts.calc_rwh_system.group_rwh_data_ym">group_rwh_data_ym</a></code></li>
<li><code><a title="yenikas_weather.scripts.calc_rwh_system.init_rwh_data" href="#yenikas_weather.scripts.calc_rwh_system.init_rwh_data">init_rwh_data</a></code></li>
<li><code><a title="yenikas_weather.scripts.calc_rwh_system.load_csv" href="#yenikas_weather.scripts.calc_rwh_system.load_csv">load_csv</a></code></li>
<li><code><a title="yenikas_weather.scripts.calc_rwh_system.main" href="#yenikas_weather.scripts.calc_rwh_system.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>